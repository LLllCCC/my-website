<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>ä¿„ç½—æ–¯æ–¹å— - Yopo</title>
    <link rel="icon" href="assets/my-avatar.jpg" />
    <link
      href="https://cdn.staticfile.net/remixicon/3.5.0/remixicon.css"
      rel="stylesheet"
    />
    <style>
      /* å…¨å±€æ ·å¼ï¼šç¦æ­¢é¡µé¢æ»šåŠ¨å’Œç¼©æ”¾ */
      body {
        overflow: hidden;
        touch-action: none;
        background: #1a1a1a;
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        font-family: "Courier New", monospace;
        user-select: none; /* ç¦æ­¢é€‰ä¸­æ–‡æœ¬ */
        -webkit-user-select: none;
      }

      .game-wrapper {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        padding: 20px;
        background: #2c2c2e;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      canvas#game {
        background: #000;
        display: block;
        border-radius: 4px;
        /* å…³é”®ä¿®å¤ï¼šä¸è¦ç”¨ CSS å¼ºè¡Œæ”¹å˜å®½é«˜ï¼Œå¦åˆ™ä¼šæ¨¡ç³Šæˆ–å˜å½¢ */
        width: 240px;
        height: 400px;
      }

      .info-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-width: 90px;
      }

      .score-box {
        background: #3a3a3c;
        padding: 10px;
        border-radius: 10px;
        text-align: center;
      }

      .score-title {
        font-size: 12px;
        color: #888;
        margin-bottom: 5px;
      }
      .score-num {
        font-size: 20px;
        font-weight: bold;
        color: #4cd964;
      }

      .btn-start {
        background: #0a84ff;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        width: 100%;
      }
      .btn-start:active {
        opacity: 0.8;
      }

      .controls-tip {
        font-size: 12px;
        color: #666;
        margin-top: auto;
        line-height: 1.5;
      }

      /* === ğŸ“± æ‰‹æœºç«¯é€‚é… === */
      .mobile-controls {
        display: none;
      } /* é»˜è®¤éšè— */

      @media (max-width: 600px) {
        .game-wrapper {
          flex-direction: column;
          align-items: center;
          gap: 10px;
          padding: 10px;
          background: transparent; /* æ‰‹æœºä¸Šå»æ‰èƒŒæ™¯æ¡†ï¼Œæ˜¾å¾—æ›´è½»é‡ */
          box-shadow: none;
        }

        .info-panel {
          flex-direction: row;
          justify-content: space-between;
          width: 240px; /* å’Œç”»å¸ƒä¸€æ ·å®½ */
          min-width: auto;
        }

        .score-box {
          flex: 1;
          padding: 5px;
        }
        #next-box {
          display: none;
        } /* æ‰‹æœºå±å¹•å°ï¼Œéšè—é¢„è§ˆå¯èƒ½æ›´å¥½ï¼Œæˆ–è€…ä¿ç•™ */
        .controls-tip {
          display: none;
        }
        .btn-start {
          width: auto;
          padding: 8px 20px;
        }

        /* æ˜¾ç¤ºæ‰‹æœºæŒ‰é’® */
        .mobile-controls {
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          gap: 15px;
          margin-top: 10px;
          width: 280px;
        }

        .m-btn {
          width: 70px;
          height: 70px;
          background: rgba(255, 255, 255, 0.15);
          border-radius: 50%;
          border: none;
          color: white;
          font-size: 28px;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto;
          backdrop-filter: blur(5px);
          -webkit-tap-highlight-color: transparent; /* å»æ‰ç‚¹å‡»é«˜äº® */
        }
        .m-btn:active {
          background: rgba(10, 132, 255, 0.6);
          transform: scale(0.95);
        }

        /* å¸ƒå±€è°ƒæ•´ï¼šä¸Šä¸‹å·¦å³ */
        #btn-up {
          grid-column: 2;
          background: rgba(255, 255, 255, 0.2);
        }
        #btn-left {
          grid-column: 1;
        }
        #btn-right {
          grid-column: 3;
        }
        #btn-down {
          grid-column: 2;
        }
      }
    </style>
  </head>
  <body>
    <a
      href="index.html"
      style="
        position: absolute;
        top: 15px;
        left: 15px;
        color: rgba(255, 255, 255, 0.5);
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
        z-index: 10;
      "
    >
      <i class="ri-arrow-left-line"></i> è¿”å›
    </a>

    <div class="game-wrapper">
      <canvas id="game" width="240" height="400"></canvas>

      <div class="info-panel">
        <div class="score-box">
          <div class="score-title">SCORE</div>
          <div class="score-num" id="score">0</div>
        </div>

        <div class="score-box" id="next-box">
          <div class="score-title">NEXT</div>
          <canvas
            id="next"
            width="80"
            height="80"
            style="background: transparent; margin: 0 auto"
          ></canvas>
        </div>

        <button class="btn-start" onclick="toggleGame()" id="startBtn">
          å¼€å§‹
        </button>

        <div class="controls-tip">
          â† â†’ ç§»åŠ¨<br />â†‘ æ—‹è½¬<br />â†“ åŠ é€Ÿ<br />ç©ºæ ¼ æš‚åœ
        </div>
      </div>
    </div>

    <div class="mobile-controls">
      <div></div>
      <button class="m-btn" id="btn-up"><i class="ri-refresh-line"></i></button>
      <div></div>

      <button class="m-btn" id="btn-left">
        <i class="ri-arrow-left-line"></i>
      </button>
      <button class="m-btn" id="btn-down">
        <i class="ri-arrow-down-line"></i>
      </button>
      <button class="m-btn" id="btn-right">
        <i class="ri-arrow-right-line"></i>
      </button>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const context = canvas.getContext("2d");
      const nextCanvas = document.getElementById("next");
      const nextContext = nextCanvas.getContext("2d");

      context.scale(20, 20);
      nextContext.scale(20, 20);

      // æ–¹å—å®šä¹‰
      const pieces = "ILJOTSZ";
      const colors = [
        null,
        "#FF0D72",
        "#0DC2FF",
        "#0DFF72",
        "#F538FF",
        "#FF8E0D",
        "#FFE138",
        "#3877FF",
      ];

      function createPiece(type) {
        if (type === "I")
          return [
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
          ];
        if (type === "L")
          return [
            [0, 2, 0],
            [0, 2, 0],
            [0, 2, 2],
          ];
        if (type === "J")
          return [
            [0, 3, 0],
            [0, 3, 0],
            [3, 3, 0],
          ];
        if (type === "O")
          return [
            [4, 4],
            [4, 4],
          ];
        if (type === "Z")
          return [
            [5, 5, 0],
            [0, 5, 5],
            [0, 0, 0],
          ];
        if (type === "S")
          return [
            [0, 6, 6],
            [6, 6, 0],
            [0, 0, 0],
          ];
        if (type === "T")
          return [
            [0, 7, 0],
            [7, 7, 7],
            [0, 0, 0],
          ];
      }

      const arena = createMatrix(12, 20);
      const player = { pos: { x: 0, y: 0 }, matrix: null, score: 0 };
      let nextPieceMatrix = null;
      let dropCounter = 0;
      let dropInterval = 1000;
      let lastTime = 0;
      let isPaused = true;
      let isGameOver = false;

      function createMatrix(w, h) {
        const matrix = [];
        while (h--) matrix.push(new Array(w).fill(0));
        return matrix;
      }

      function collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (
              m[y][x] !== 0 &&
              (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0
            ) {
              return true;
            }
          }
        }
        return false;
      }

      function drawMatrix(matrix, offset, ctx) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              // å¡«å……é¢œè‰²
              ctx.fillStyle = colors[value];
              ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
              // ç»˜åˆ¶å†…å‘å…‰/ç«‹ä½“æ„Ÿ
              ctx.lineWidth = 0.05;
              ctx.strokeStyle = "rgba(255,255,255,0.5)";
              ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
              // ç»˜åˆ¶é˜´å½±
              ctx.fillStyle = "rgba(0,0,0,0.2)";
              ctx.fillRect(x + offset.x + 0.1, y + offset.y + 0.8, 0.8, 0.1);
              ctx.fillRect(x + offset.x + 0.8, y + offset.y + 0.1, 0.1, 0.8);
            }
          });
        });
      }

      function draw() {
        context.fillStyle = "#000";
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawMatrix(arena, { x: 0, y: 0 }, context);
        drawMatrix(player.matrix, player.pos, context);

        nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        if (nextPieceMatrix) {
          const offsetX = (4 - nextPieceMatrix[0].length) / 2;
          const offsetY = (4 - nextPieceMatrix.length) / 2;
          drawMatrix(nextPieceMatrix, { x: offsetX, y: offsetY }, nextContext);
        }
      }

      function merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
          });
        });
      }

      function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
          for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
          }
        }
        if (dir > 0) matrix.forEach((row) => row.reverse());
        else matrix.reverse();
      }

      function playerDrop() {
        player.pos.y++;
        if (collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          playerReset();
          arenaSweep();
          updateScore();
        }
        dropCounter = 0;
      }

      function playerMove(offset) {
        player.pos.x += offset;
        if (collide(arena, player)) player.pos.x -= offset;
      }

      function playerReset() {
        if (!nextPieceMatrix)
          nextPieceMatrix = createPiece(
            pieces[(pieces.length * Math.random()) | 0],
          );
        player.matrix = nextPieceMatrix;
        nextPieceMatrix = createPiece(
          pieces[(pieces.length * Math.random()) | 0],
        );

        player.pos.y = 0;
        player.pos.x =
          ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);

        if (collide(arena, player)) {
          isGameOver = true;
          isPaused = true;
          document.getElementById("startBtn").innerText = "é‡æ¥";
          document.getElementById("startBtn").style.background = "#FF3B30";
        }
      }

      function playerRotate(dir) {
        const pos = player.pos.x;
        let offset = 1;
        rotate(player.matrix, dir);
        while (collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
          }
        }
      }

      function arenaSweep() {
        let rowCount = 1;
        outer: for (let y = arena.length - 1; y > 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) continue outer;
          }
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          player.score += rowCount * 10;
          rowCount *= 2;
        }
      }

      function updateScore() {
        document.getElementById("score").innerText = player.score;
      }

      function update(time = 0) {
        if (isPaused) return;
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) playerDrop();
        draw();
        requestAnimationFrame(update);
      }

      function toggleGame() {
        const btn = document.getElementById("startBtn");
        if (isGameOver) {
          arena.forEach((row) => row.fill(0));
          player.score = 0;
          updateScore();
          isGameOver = false;
          playerReset();
          isPaused = false;
          btn.innerText = "æš‚åœ";
          btn.style.background = "#FF9500";
          update();
        } else if (isPaused) {
          isPaused = false;
          if (!player.matrix) playerReset();
          btn.innerText = "æš‚åœ";
          btn.style.background = "#FF9500";
          update();
        } else {
          isPaused = true;
          btn.innerText = "ç»§ç»­";
          btn.style.background = "#34C759";
        }
      }

      document.addEventListener("keydown", (event) => {
        if (isPaused && event.keyCode !== 32) return;
        if (event.keyCode === 37) playerMove(-1);
        else if (event.keyCode === 39) playerMove(1);
        else if (event.keyCode === 40) playerDrop();
        else if (event.keyCode === 38) playerRotate(1);
        else if (event.keyCode === 32) toggleGame();
      });

      // === ğŸš€ æ‰‹æœºç«¯é•¿æŒ‰è¿ç»­ç§»åŠ¨é€»è¾‘ ===
      const setupMobileBtn = (id, action) => {
        const btn = document.getElementById(id);
        let interval;

        // è§¦æ‘¸å¼€å§‹
        btn.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault(); // é˜²æ­¢åŒå‡»ç¼©æ”¾
            if (isPaused) return;
            action(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
            // å»¶æ—¶åå¼€å¯è¿å‘
            setTimeout(() => {
              if (interval) clearInterval(interval);
              // åªæœ‰å½“å‰è¿˜åœ¨è§¦æ‘¸ä¸­æ‰å¼€å¯è¿å‘
              if (btn.matches(":active")) {
                interval = setInterval(action, 100); // 100ms è¿å‘ä¸€æ¬¡
              }
            }, 200);
          },
          { passive: false },
        );

        // è§¦æ‘¸ç»“æŸ/å–æ¶ˆ/ç¦»å¼€
        const stop = (e) => {
          if (e) e.preventDefault();
          clearInterval(interval);
        };
        btn.addEventListener("touchend", stop);
        btn.addEventListener("touchcancel", stop);
      };

      setupMobileBtn("btn-left", () => playerMove(-1));
      setupMobileBtn("btn-right", () => playerMove(1));
      setupMobileBtn("btn-down", () => playerDrop());
      setupMobileBtn("btn-up", () => playerRotate(1));

      // åˆå§‹åŒ–
      playerReset();
      isPaused = true;
      draw();
    </script>
  </body>
</html>
